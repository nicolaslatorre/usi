126161,A,Where do the responsibilities of a Db Abstraction in PHP start and end? In PHP what is the best practice for laying out the responsibilities of a Db Abstraction Layer? Is OOP a good idea in terms of performance? How much should be generic object code and how much should be very specific functions? There are already some great solutions for this. A DAL is not a simple thing especially since so many security concerns are involved. I would suggest checking out PDO and MySQLi. Even if you write a wrapper class for one of them the heavy lifting will be done for you in a robust and secure way.  In most applications I have written there are generally two different types of data access. One is for transactional operations: retrieving specific objects from the datastore modifying them and saving them back. I've found a solid ORM to be the best solution here. Don't try writing your own (as interesting as it might be.) The other common type of data access is for reporting. ORMs aren't the best solution here which is why I usually go with a scheme that uses custom SQL queries. Plain ol' PDO works well here. You can create a special value object just for that report and have the PDO query fetch the values into the object. Reports need to be fast and building them using an ORM layer is usually just too slow and cumbersome.,php sql mysql database
85,A,"Flat File Databases What are your best practices around creating flat file database structures in PHP? A lot of the more mature PHP flat file frameworks I see out there attempt to implement SQL-like query syntax which is over the top for my purposes in most cases (I would just use a database at that point). Are there any elegant tricks out there to get good performance and features with the small code overhead one would want by taking on this problem in the first place? One framework I'm considering would be for a blogging platform. Since just about any possible view of data you would want would be sorted by date I was thinking about this structure: One directory per content node: ./content/YYYYMMDDHHMMSS/ Subdirectories of each node including /tags /authors /comments as well as simple text files in the node directory for pre- and post-rendered content and the like. This would allow a simple PHP glob() call (and probably a reversal of the result array) to query on just about anything within the content structure:glob(""content/*/tags/funny""); would return paths including all articles tagged ""funny"".  One way to store flat-file content would be to save literal arrays to php files. For example: $data = array(); if( $_POST ) { $data = $_POST; $content = ""<?php\n""; $content .= '$data=' . var_export($data true) . ""\n""; $content .= ""?>""; save_to_file($filename $content); } // echo form `"" That's true. serialize() can be pretty useful for that as well. You could serialize but this saves a step since you don't have to unserialize. Not sure if its actually better performance-wise. I think the trick to coming up with a viable system is finding some way to index the data nodes without killing yourself with complexity. Maybe have one central file that keeps track of all indexes? Like tags.txt which has a list of all post id's associated with each tags. May have to keep redundant data around to save time.  In my opinion using a ""Flat File Database"" in the sense you're meaning (and the answer you've accepted) isn't neccesarily the best way to go about things. First of all using serialize() and unserialize() can cause MAJOR headaches if someone gets in and edits the file (they can in fact put arbritrary code in your ""database"" to be run each time.) Personally I'd say - why not look to the future? There have been so many times that I've had issues because I've been creating my own ""proprietary"" files and the project has exploded to a point where it needs a database and I'm thinking ""you know I wish I'd written this for a database to start with"" - because the refactoring of the code takes way too much time and effort. From this I've learnt that future proofing my application so that when it gets bigger I don't have to go and spend days refactoring is the way to go forward. How do I do this? SQLite. It works as a database uses SQL and is pretty easy to change over to mySQL (espescially if you're using abstracted classes for database manipulation like I do!) In fact espescially with the ""accepted answer""'s method it can drastically cut the memory usage of your app (you don't have to load all the ""RECORDS"" into PHP)  Well what is the nature of the flat databases. Are they large or small. Is it simple arrays with arrays in them? if its something simple say userprofiles built as such: $user = array(""name"" => ""dubayou"" ""age"" => 20 ""websites"" => array(""dubayou.com""""willwharton.com""""codecream.com"") ""and_one"" => ""more""); and to save or update the db record for that user. $dir = ""../userdata/""; //make sure to put it bellow what the server can reach. file_put_contents($dir.$user['name']serialize($user)); and to load the record for the user function &get_user($name){ return unserialize(file_get_contents(""../userdata/"".$name)); } but again this implementation will vary on the application and nature of the database you need.  I have written two simple functions designed to store data in a file. You can judge for yourself if it's useful in this case. The point is to save a php variable (if it's either an array a string or an object) to a file. <?php function varname(&$var) { $oldvalue=$var; $var='AAAAB3NzaC1yc2EAAAABIwAAAQEAqytmUAQKMOj24lAjqKJC2Gyqhbhb+DmB9eDDb8+QcFI+QOySUpYDn884rgKB6EAtoFyOZVMA6HlNj0VxMKAGE+sLTJ40rLTcieGRCeHJ/TI37e66OrjxgB+7tngKdvoG5EF9hnoGc4eTMpVUDdpAK3ykqR1FIclgk0whV7cEn/6K4697zgwwb5R2yva/zuTX+xKRqcZvyaF3Ur0Q8T+gvrAX8ktmpE18MjnA5JuGuZFZGFzQbvzCVdN52nu8i003GEFmzp0Ny57pWClKkAy3Q5P5AR2BCUwk8V0iEX3iu7J+b9pv4LRZBQkDujaAtSiAaeG2cjfzL9xIgWPf+J05IQ=='; foreach($GLOBALS as $var_name => $value) { if ($value === 'AAAAB3NzaC1yc2EAAAABIwAAAQEAqytmUAQKMOj24lAjqKJC2Gyqhbhb+DmB9eDDb8+QcFI+QOySUpYDn884rgKB6EAtoFyOZVMA6HlNj0VxMKAGE+sLTJ40rLTcieGRCeHJ/TI37e66OrjxgB+7tngKdvoG5EF9hnoGc4eTMpVUDdpAK3ykqR1FIclgk0whV7cEn/6K4697zgwwb5R2yva/zuTX+xKRqcZvyaF3Ur0Q8T+gvrAX8ktmpE18MjnA5JuGuZFZGFzQbvzCVdN52nu8i003GEFmzp0Ny57pWClKkAy3Q5P5AR2BCUwk8V0iEX3iu7J+b9pv4LRZBQkDujaAtSiAaeG2cjfzL9xIgWPf+J05IQ==') { $var=$oldvalue; return $var_name; } } $var=$oldvalue; return false; } function putphp(&$var $file=false) { $varname=varname($var); if(!$file) { $file=$varname.'.php'; } $pathinfo=pathinfo($file); if(file_exists($file)) { if(is_dir($file)) { $file=$pathinfo['dirname'].'/'.$pathinfo['basename'].'/'.$varname.'.php'; } } file_put_contents($file'<?php'.""\n\$"".$varname.'='.var_export($var true)."";\n""); return true; } This is a four-year-old question with an accepted answer and many additional answers. Consider focusing on newer questions unless the accepted answer here is clearly wrong or inadequate.  IMHO you have two options if you want to avoid homebrewing something: 1) SQLite If you're familiar with PDO you can install a PDO driver that supports SQLite. Never used it but I have used PDO a ton with MySQL. I'm going to give this a shot on a current project. 2) XML Done this many times for relatively small amounts of data. XMLReader is a lightweight read-forward cursor-style class. SimpleXML makes it simple to read an XML document into an object that you can access just like any other class instance.  A low level object API flatfile database is Mimesis (an open source PHP flat file database low-level API).  This one is inspiring as a practical solution: https://github.com/mhgolkar/FlatFire It uses multiple strategies to handling data... [Copied from Readme File] Free or Structured or Mixed - STRUCTURED Regular (table row column) format. [DATABASE] / \ TX TableY \_____________________________ |ROW_0 Colum_0 Colum_1 Colum_2| |ROW_1 Colum_0 Colum_1 Colum_2| |_____________________________| - FREE More creative data storing. You can store data in any structure you want for each (free) element its similar to storing an array with a unique ""Id"". [DATABASE] / \ EX ElementY (ID) \________________ |Field_0 Value_0 | |Field_1 Value_1 | |Field_2 Value_2 | |________________| recall [ID]: get_free(""ElementY"") --> array([Field_0]=>Value_0[Field_1]=>Value_1... - MIXD (Mixed) Mixed databases can store both free elements and tables.If you add a table to a free db or a free element to a structured db flat fire will automatically convert FREE or SRCT to MIXD database. [DATABASE] / \ EX TY  You might consider SQLite. It's almost as simple as flat files but you do get a SQL engine for querying. It works well with PHP too. SQLite was build into 5.0+ by default but discountinued (!) from PHP 5.4+ on !!! As I write this in July 2012 SQLite will not work on up-to-date systems anymore by default. Official statement [here](http://www.php.net/manual/en/sqlite.requirements.php) Installing the SQLite PDO driver is pretty trivial if you have server access. On Ubuntu/Debian running Apache2 just do apt-get install php5-sqlite service apache2 restart  Here's the code we use for Lilina. It stores each entry as a separate file which we found is efficient enough for use (no unneeded data is loaded and it's faster to save).  If you're going to use a flat file to persist data use XML to structure the data. PHP has a built-in XML parser.  That's true. serialize() can be pretty useful for that as well. I think the trick to coming up with a viable system is finding some way to index the data nodes without killing yourself with complexity. This is post #100! post 100 :D upvote  Just pointing out a potential problem with a flat file database with this type of system: data|some text|more data row 2 data|bla hbalh|more data ...etc The problem is that the cell data contains a ""|"" or a ""\n"" then the data will be lost. Sometimes it would be easier to split by combinations of letters that most people wouldn't use. For example: Column splitter: #$% (Shift+345) Row splitter: ^&* (Shift+678) Text file: test data#$%blah blah#$%^&*new row#$%new row data 2 Then use: explode(""#$%"" $data); use foreach the explode again to separate columns Or anything along these lines. Also I might add that flat file databases are good for systems with small amounts of data (ie. less than 20 rows) but become huge memory hogs for larger databases.  If you want a human-readable result you can also use this type of file : ofaurax|27|male|something| another|24|unknown|| ... This way you have only one file you can debug it (and manually fix) easily you can add fields later (at the end of each line) and the PHP code is simple (for each line split according to |). However the drawbacks is that you should parse the entire file to search something (if you have millions of entry it's not fine) and you should handle the separator in data (for example if the nick is WaR|ordz).",php sql database flat-file
315331,A,"Best approach to limit database traffic on large query? I have a database that i'm dealing with which is updated every few hours remotely (not on any specific time span) and i have no control over the administration of it. I have web clients connecting to it to view information contained within it. These clients (coded using PHP and Javascript) might be checking the database very often (impatient users) even though there may not be any change to the database itself and the check will involve quite a lengthy query involving lots of lookups and cross referencing etc. So in order to cut down on database queries and to keep things snappy what would be the best way to limit the number of times the clients will actually run the whole query on the database? To make things crystal clear i have no way of altering the database i can only query it. But i have full control over the source of the web client. I would take a look at Zend_Cache. Each query will only run once for the lifetime of the cache (which can be easily changed). Sessions aren't a viable solution since the same query will run at least once per user. Sessions can also be easily renewed. You'll want to check if the result set exists in the cache. If not cache the result set with a unique identifier: $query = ""SELECT * FROM really_big_table""; $cache_query = md5($query); if(!$result = $cache->load($cache_query)) { $result = $db->fetchAll($query); $cache->save($result $cache_query); } By using a cache you are setting your own time frame for when data is updated for all users.  Do you have control over the web app? If users are logged in and have sessions associated with them you could cache the time since a user last queried the database and refuse to hand back new data if a request is beneath some threshold interval since the last query. PHP Sessions I should add: Caching solutions such as truppo suggests can also reduce database round-trips and should be investigated and considered.  You should use some sort of cache. For more serious sites take a look at memcached. If you are in a smaller scale cache the results to file by serializing it. You could also use something like APC to cache things in memory if it's a small enough result set.",php sql database
